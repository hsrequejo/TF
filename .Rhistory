times = times + 1
}
}
if (times < number_of_layers) {
links_df[i,1] = pair_temp[1]
links_df[i,2] = pair_temp[2]
links_df[i,3] = layer_choosen
i = i+1
}
}
links_df
# minimizes dual effect (not sure if it removes the dual link problem completely)
for (i in 1:length(links_df[,1])) {
for (j in 1:length(links_df[,1])) {
if (links_df[i,1] == links_df[j,1] && links_df[i,2] == links_df[j,2] && links_df[i,3] == links_df[j,3] && i != j) {
while(links_df[i,3] == links_df[j,3]){
layers_rand = sample(1:number_of_layers, number_of_layers, replace=FALSE)
links_df[i,3] = layers_rand[1]
}
}
}
}
#checks for multiple links on the same layer
number_of_duals = 0
duals = data.frame(indexa = numeric(0), indexb = numeric(0), from = numeric(0), to = numeric(0), layer = numeric(0))
k = 1
for (i in 1:length(links_df[,1])) {
for (j in 1:length(links_df[,1])) {
if (links_df[i,1] == links_df[j,1] && links_df[i,2] == links_df[j,2] && links_df[i,3] == links_df[j,3] && i != j) {
number_of_duals = number_of_duals + 1
duals[k,1] = i
duals[k,2] = j
duals[k,3] = links_df[i,1]
duals[k,4] = links_df[i,2]
duals[k,5] = links_df[i,3]
k = k + 1
}
}
}
#removes dual links entirely
links_df = links_df[!seq_len(nrow(links_df)) %in% duals[,1], ]
#extract the nodes list
# nodes_df = nodes_ID
nodes_raw = links_df[,1]
nodes_raw = append(nodes_raw, links_df[,2])
nodes_raw
nodes_df = unique(nodes_raw)
nodes_df = sort(nodes_df)
nodes_df = cbind(nodes_df, rep("filler", length(nodes_df)))
colnames(nodes_df) = c("name", "enchimento")
nodes_df
links_df
b = Sys.time()
paste0(round(as.numeric(difftime(time1 = b, time2 = a, units = "secs")), 3), " Seconds")
#gera uma string com o nome do arquivo csv da seguinte forma: camadas_conexoes_nos
file_name_links = paste("rand_ml_",number_of_layers, "_", number_of_conections, "_", number_of_nodes, "_links.csv", sep ="")
file_name_nodes = paste("rand_ml_",number_of_layers, "_", number_of_conections, "_", number_of_nodes, "_nodes.csv", sep ="")
#creates a csv file for the nodes_df and links_df using the file name on the directory of this R script
dirname(rstudioapi::getActiveDocumentContext()$path)
write.csv(links_df, file_name_links, row.names = FALSE, quote = FALSE)
write.csv(nodes_df, file_name_nodes, row.names = FALSE, quote = FALSE)
nodes = read.csv("./Network_Inputs/rand_ml_2_100_30_nodes.csv", header=T, as.is=T)
links = read.csv("./Network_Inputs/rand_ml_2_100_30_links.csv", header=T, as.is=T)
# Pra ser usado no corpo do texto do documento R Markdown
net_name = "rand_ml_2_100_30"
#string com o referencia no arquivo .bib, e.g. "Mello2019". Usada para fazer a citação no R Markdown
bib_ref = "vazio"
#Caminho onde deve ser salvo o .RData. Lembrar de mudar o nome para nao sobreescrever o antigo
file_to_save = paste("./RDatas/", net_name, ".RData", sep="")
#----
#ordena os nos. Importante para referenciar os nos corretamente
nodes = nodes[order(nodes$name),]
###############################################################
# Faz a analise de G para diferentes valores de omega e gamma #
# e salva as variaveis necessarias em um .RData para serem    #
# usadas no arquivo .Rmd para gerar o relatorio final         #
#                                                             #
# Henrique S Requejo 23/07/2020                               #
###############################################################
# Uncoment abaixo para instalar----------------------------------
# install.packages('multinet', dependencies = TRUE)
# install.packages('igraph')
# install.packages('plyr')
# install.packages('dplyr')
# install.packages('ggplot2')
# install.packages('RColorBrewer')
# install.packages('kableExtra')
# install.packages('akima')
# install.packages('plot3D')
#----
#Bibliotecas--------
library(multinet)
library(igraph)
library(plyr)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(kableExtra)
library(akima)
library(plot3D)
#-------------------
#Funcoes auxiliares-------------------------------------------------
source("Aux_functions.R", encoding="utf-8")
#-------------------------------------------------------------------
# Client
# informa o R que o diretório de trabalho é o do documento atual
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Entradas. Nao esquecer de alterar o net_name, bib_ref e file_to_save, pois serao usadas no RMarkdown----
#comentar/descomentar (ctrl+shift+c) para escolher qual rede usar como entrada ou mudar o caminho manualmente
# nodes = read.csv("./Network_Inputs/bat-plant_nodes.csv", header=T, as.is=T)
# links = read.csv("./Network_Inputs/bat-plant_links.csv", header=T, as.is=T)
# nodes = read.csv("./Network_Inputs/ant-plant_nodes.csv", header=T, as.is=T)
# links = read.csv("./Network_Inputs/ant-plant_links.csv", header=T, as.is=T)
# nodes = read.csv("./Network_Inputs/Flo_nodes.csv", header=T, as.is=T)
# links = read.csv("./Network_Inputs/Flo.csv", header=T, as.is=T)
nodes = read.csv("./Network_Inputs/rand_ml_2_100_30_nodes.csv", header=T, as.is=T)
links = read.csv("./Network_Inputs/rand_ml_2_100_30_links.csv", header=T, as.is=T)
# Pra ser usado no corpo do texto do documento R Markdown
net_name = "rand_ml_2_100_30"
#string com o referencia no arquivo .bib, e.g. "Mello2019". Usada para fazer a citação no R Markdown
bib_ref = "vazio"
#Caminho onde deve ser salvo o .RData. Lembrar de mudar o nome para nao sobreescrever o antigo
file_to_save = paste("./RDatas/", net_name, ".RData", sep="")
#----
#ordena os nos. Importante para referenciar os nos corretamente
nodes = nodes[order(nodes$name),]
# Converte nodes e links em objeto multinet para an?lise e Igraph para visualizacao usando uma funcao auxilar
net_multinet = Convert_to_Multinet(nodes, links)
#salva um dataframe com as propriedades da rede
propriedades_rede = Net_prop(net_multinet)
#calcula um layout (igraph) e plota o grafo usando a funcao aux CustomPlot----
links_no_dupl = links[-which(duplicated(links[,c("from", "to")])==T),] # retira os duplicados para nao influenciar no layout
net_layout = graph_from_data_frame(d = links_no_dupl, vertices = nodes, directed = F) #usado somente para calcular o layout
layout = layout_nicely(net_layout) # igraph
#----
#Gera o banco de dados 'seq_G_Merged' e o vetor de omegas vec_W para um numero dado de particoes de omega----
partitions_of_omega = 10 # numero de particoes entre zero e 1 para omega
seq_G = Create_seq_G_Merged(net_multinet, partitions_of_omega)
vec_W = Create_vec_W(partitions_of_omega)
#----
# variaveis para inicializar o vetor de gammas
gamma_min = 0.25
gamma_max = 4
gamma_spacing = 0.25
gammas = seq(from = gamma_min, to = gamma_max, by = gamma_spacing)
Seq_G_Mean_gamma_list = list() #guarda os diferentes datasets de Seq_G_Mean
G_norm_ordered_list = list() #guarda os diferentes nohs selecionados para plot
G_norm_list = list()
cont_perc = 1 # usado apenas para mostrar a porcentagem de conclusao
for (gamma_index in 1:length(gammas)) {
#gerar uma sequencia de banco de dados seqG----
seq_G_list = list()
iterations = 100
for (i in 1:iterations) {
seq_G_list[[i]] = Create_seq_G_Merged(net_multinet, partitions_of_omega, gamma = gammas[gamma_index])
cat(cont_perc*100/(iterations*length(gammas)), "%  ")
cont_perc = cont_perc + 1
}
#----
#Remove os nomes da primeira coluna do SeqG list. Tendo problemas para somar deviso a essas strings
seq_G_list_no_names = list()
for (i in 1:length(seq_G_list)) {
seq_G_list_temp = seq_G_list[[i]]
seq_G_list_temp[,1] = 1
seq_G_list_no_names[[i]] = seq_G_list_temp
}
#soma todos os dataframes em seq_G_list em um df----
seq_G_sum = seq_G_list_no_names[[1]]
for (i in 2:length(seq_G_list)) {
seq_G_sum = seq_G_sum + seq_G_list_no_names[[i]]
}
seq_G_sum
#----
#calcula a media de seq_G_sum
seq_G_mean = seq_G_sum / iterations
#insere o nome dos nohs novamente no df de media. Este valor se perde no caminho devido aos calculos
seq_G_mean[,1] = seq_G_list[[1]]$actor
#calcula o desvio padrao usando a funcao auxiliar 'StdDev_list_of_seq_G'
seq_G_StdDev = StdDev_list_of_seq_G(seq_G_list)
#vetor ordenado de acordo com o indice G do df mean----
nodes_G_norm = Sort_Nodes_by_Total_G(seq_G_mean, ordered = FALSE)
nodes_G_norm_Ordered = Sort_Nodes_by_Total_G(seq_G_mean, ordered = TRUE)
#----
#Guarda o Seq_G_mean e nodes_G_norm em uma lista de acordo com o gamma usado
Seq_G_Mean_gamma_list[[gamma_index]] = cbind(seq_G_mean, gammas[gamma_index])
G_norm_list[[gamma_index]] = nodes_G_norm
}
#dataframe equivalente ao Seg_G_Mean, mas agora considerando gamma, usando funcao auxiliar
seq_Gnorm_gamma_mean = Unite_list_of_dataframes(Seq_G_Mean_gamma_list)
#enconta os valores medios de G levendo em conta a variacao de gamma
G_norm_sum = G_norm_list[[1]]
for (i in 2:length(G_norm_list)) {
G_norm_sum = G_norm_sum + G_norm_list[[i]]
}
#----
#calcula a media de seq_G_sum
G_norm_mean = G_norm_sum / (length(G_norm_list))
G_norm_mean
#ordena G_norm_mean
G_norm_mean_ordered =  sort(G_norm_mean, decreasing = TRUE)
#seleciona quatro noh e plota suas curvas de decaimento G em relacao a w e gamma
selection = Select_Example_Nodes(G_norm_mean_ordered)
for (i in 1:length(selection)) {
#plota a familia de curvas G para cada gamma de um no escolhido----
chosen_node = names(selection[i])
plots = G_curves_for_different_gammas(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
plot(plots)
Plot_G_gamma_omega_suf_3D(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
#Salva as as variaveis que são usadas no R Markdown em um arquivo .RData
save(gammas, vec_W, iterations, partitions_of_omega, links, nodes, layout, Seq_G_Mean_gamma_list,
seq_Gnorm_gamma_mean, G_norm_mean, G_norm_mean_ordered, net_name, bib_ref, file = file_to_save)
load("./RDatas/rand_ml_2_100_30.RData")
load("./RDatas/ants.RData")
gammas
vec_W
iterations
partitions_of_omega
links
nodes
layout
#Seq_G_Mean_gamma_list
seq_Gnorm_gamma_mean
G_norm_mean
G_norm_mean_ordered
net_name
bib_ref
#----
Custom_plot2D(links, nodes, layout, vertex_label_cex = NULL, vertex_size = 3)
#Em construcao
models <- c(evolution_er_ml(20), evolution_er_ml(20), evolution_er_ml(20), evolution_er_ml(20), evolution_er_ml(20))
pr_external <- c(.25,.25,.25,.25,.25)
pr_internal <- c(.25,.25,.25,.25,.25)
dependency <- matrix(c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),5,5)
teste = grow_ml(20, 100, models, pr_internal, pr_external, dependency)
teste
write_ml(teste, file = "teste_write_output.txt", format = "multilayer", layers = character(0),
sep = ',', merge.actors = TRUE, all.actors = FALSE)
teste_igraph = as.igraph(teste, layers = NULL, merge.actors = TRUE, all.actors = FALSE)
#mostra oque foi savo no RData para debug
load("./RDatas/rand_ml_2_100_30.RData")
load("./RDatas/rand_ml_2_100_30.RData")
#load("./RDatas/ants.RData")
gammas
vec_W
iterations
partitions_of_omega
links
nodes
layout
#Seq_G_Mean_gamma_list
seq_Gnorm_gamma_mean
G_norm_mean
G_norm_mean_ordered
net_name
bib_ref
lnum = num_layers_ml(net_multinet)
lnum
load("./RDatas/rand_ml_2_100_30.RData")
#load("./RDatas/ants.RData")
gammas
vec_W
iterations
partitions_of_omega
links
nodes
layout
#Seq_G_Mean_gamma_list
seq_Gnorm_gamma_mean
G_norm_mean
G_norm_mean_ordered
net_name
bib_ref
lnum = num_layers_ml(net_multinet) #numero de camadas da rede
# serve para juntar toas as camadas em uma string soh. Bom para usar como texto
lnames = layers_ml(net_multinet)
lnames2 = ""
for (i in 1:lnum) {
if (i==1) {
lnames2 = paste(lnames[i])
}
else if (i==lnum) {
lnames2 = paste(lnames2, " e ", lnames[i])
}
else{
lnames2 = paste(lnames2, ", ", lnames[i])
}
}
nnum = num_actors_ml(net_multinet, layers = character(0))
cnum = num_edges_ml(net_multinet)
#Monta a coluna de valores e nome da propriedade para montar o df propriedades_da_rede
numbers = c(lnum, lnames2, nnum, cnum)
labels = c("Número de Camadas", "Tipo de conexões", "Número de nós", "Número de conexões")
#Monta a tabela de prorpiedades da rede
propriedades_rede = data.frame(labels, numbers)
names(propriedades_rede) = c("Propriedade", "Valor")
propriedades_rede
net_multinet = Convert_to_Multinet(nodes, links)
lnum = num_layers_ml(net_multinet)
lnum
net_multinet
load("./RDatas/ants.RData")
gammas
vec_W
iterations
partitions_of_omega
links
nodes
layout
#Seq_G_Mean_gamma_list
seq_Gnorm_gamma_mean
G_norm_mean
G_norm_mean_ordered
net_name
bib_ref
net_multinet = Convert_to_Multinet(nodes, links)
lnum = num_layers_ml(net_multinet)
net_multinet
###############################################################
# Faz a analise de G para diferentes valores de omega e gamma #
# e salva as variaveis necessarias em um .RData para serem    #
# usadas no arquivo .Rmd para gerar o relatorio final         #
#                                                             #
# Henrique S Requejo 23/07/2020                               #
###############################################################
# Uncoment abaixo para instalar----------------------------------
# install.packages('multinet', dependencies = TRUE)
# install.packages('igraph')
# install.packages('plyr')
# install.packages('dplyr')
# install.packages('ggplot2')
# install.packages('RColorBrewer')
# install.packages('kableExtra')
# install.packages('akima')
# install.packages('plot3D')
#----
#Bibliotecas--------
library(multinet)
library(igraph)
library(plyr)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(kableExtra)
library(akima)
library(plot3D)
#-------------------
#Funcoes auxiliares-------------------------------------------------
source("Aux_functions.R", encoding="utf-8")
#-------------------------------------------------------------------
# Client
# informa o R que o diretório de trabalho é o do documento atual
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Entradas. Nao esquecer de alterar o net_name, bib_ref e file_to_save, pois serao usadas no RMarkdown----
#comentar/descomentar (ctrl+shift+c) para escolher qual rede usar como entrada ou mudar o caminho manualmente
# nodes = read.csv("./Network_Inputs/bat-plant_nodes.csv", header=T, as.is=T)
# links = read.csv("./Network_Inputs/bat-plant_links.csv", header=T, as.is=T)
# nodes = read.csv("./Network_Inputs/ant-plant_nodes.csv", header=T, as.is=T)
# links = read.csv("./Network_Inputs/ant-plant_links.csv", header=T, as.is=T)
# nodes = read.csv("./Network_Inputs/Flo_nodes.csv", header=T, as.is=T)
# links = read.csv("./Network_Inputs/Flo.csv", header=T, as.is=T)
nodes = read.csv("./Network_Inputs/rand_ml_2_100_30_nodes.csv", header=T, as.is=T)
links = read.csv("./Network_Inputs/rand_ml_2_100_30_links.csv", header=T, as.is=T)
# Pra ser usado no corpo do texto do documento R Markdown
net_name = "teste"
#string com o referencia no arquivo .bib, e.g. "Mello2019". Usada para fazer a citação no R Markdown
bib_ref = "vazio"
#Caminho onde deve ser salvo o .RData. Lembrar de mudar o nome para nao sobreescrever o antigo
file_to_save = paste("./RDatas/", net_name, ".RData", sep="")
#----
#ordena os nos. Importante para referenciar os nos corretamente
nodes = nodes[order(nodes$name),]
# Converte nodes e links em objeto multinet para an?lise e Igraph para visualizacao usando uma funcao auxilar
net_multinet = Convert_to_Multinet(nodes, links)
#salva um dataframe com as propriedades da rede
propriedades_rede = Net_prop(net_multinet)
#calcula um layout (igraph) e plota o grafo usando a funcao aux CustomPlot----
links_no_dupl = links[-which(duplicated(links[,c("from", "to")])==T),] # retira os duplicados para nao influenciar no layout
net_layout = graph_from_data_frame(d = links_no_dupl, vertices = nodes, directed = F) #usado somente para calcular o layout
layout = layout_nicely(net_layout) # igraph
#----
#Gera o banco de dados 'seq_G_Merged' e o vetor de omegas vec_W para um numero dado de particoes de omega----
partitions_of_omega = 10 # numero de particoes entre zero e 1 para omega
seq_G = Create_seq_G_Merged(net_multinet, partitions_of_omega)
vec_W = Create_vec_W(partitions_of_omega)
#----
# variaveis para inicializar o vetor de gammas
gamma_min = 0.25
gamma_max = 4
gamma_spacing = 0.25
gammas = seq(from = gamma_min, to = gamma_max, by = gamma_spacing)
Seq_G_Mean_gamma_list = list() #guarda os diferentes datasets de Seq_G_Mean
G_norm_ordered_list = list() #guarda os diferentes nohs selecionados para plot
G_norm_list = list()
cont_perc = 1 # usado apenas para mostrar a porcentagem de conclusao
for (gamma_index in 1:length(gammas)) {
#gerar uma sequencia de banco de dados seqG----
seq_G_list = list()
iterations = 100
for (i in 1:iterations) {
seq_G_list[[i]] = Create_seq_G_Merged(net_multinet, partitions_of_omega, gamma = gammas[gamma_index])
cat(cont_perc*100/(iterations*length(gammas)), "%  ")
cont_perc = cont_perc + 1
}
#----
#Remove os nomes da primeira coluna do SeqG list. Tendo problemas para somar deviso a essas strings
seq_G_list_no_names = list()
for (i in 1:length(seq_G_list)) {
seq_G_list_temp = seq_G_list[[i]]
seq_G_list_temp[,1] = 1
seq_G_list_no_names[[i]] = seq_G_list_temp
}
#soma todos os dataframes em seq_G_list em um df----
seq_G_sum = seq_G_list_no_names[[1]]
for (i in 2:length(seq_G_list)) {
seq_G_sum = seq_G_sum + seq_G_list_no_names[[i]]
}
seq_G_sum
#----
#calcula a media de seq_G_sum
seq_G_mean = seq_G_sum / iterations
#insere o nome dos nohs novamente no df de media. Este valor se perde no caminho devido aos calculos
seq_G_mean[,1] = seq_G_list[[1]]$actor
#calcula o desvio padrao usando a funcao auxiliar 'StdDev_list_of_seq_G'
seq_G_StdDev = StdDev_list_of_seq_G(seq_G_list)
#vetor ordenado de acordo com o indice G do df mean----
nodes_G_norm = Sort_Nodes_by_Total_G(seq_G_mean, ordered = FALSE)
nodes_G_norm_Ordered = Sort_Nodes_by_Total_G(seq_G_mean, ordered = TRUE)
#----
#Guarda o Seq_G_mean e nodes_G_norm em uma lista de acordo com o gamma usado
Seq_G_Mean_gamma_list[[gamma_index]] = cbind(seq_G_mean, gammas[gamma_index])
G_norm_list[[gamma_index]] = nodes_G_norm
}
#dataframe equivalente ao Seg_G_Mean, mas agora considerando gamma, usando funcao auxiliar
seq_Gnorm_gamma_mean = Unite_list_of_dataframes(Seq_G_Mean_gamma_list)
#enconta os valores medios de G levendo em conta a variacao de gamma
G_norm_sum = G_norm_list[[1]]
for (i in 2:length(G_norm_list)) {
G_norm_sum = G_norm_sum + G_norm_list[[i]]
}
#----
#calcula a media de seq_G_sum
G_norm_mean = G_norm_sum / (length(G_norm_list))
G_norm_mean
#ordena G_norm_mean
G_norm_mean_ordered =  sort(G_norm_mean, decreasing = TRUE)
#seleciona quatro noh e plota suas curvas de decaimento G em relacao a w e gamma
selection = Select_Example_Nodes(G_norm_mean_ordered)
for (i in 1:length(selection)) {
#plota a familia de curvas G para cada gamma de um no escolhido----
chosen_node = names(selection[i])
plots = G_curves_for_different_gammas(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
plot(plots)
Plot_G_gamma_omega_suf_3D(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
#Salva as as variaveis que são usadas no R Markdown em um arquivo .RData
save(gammas, vec_W, iterations, partitions_of_omega, links, nodes, layout, Seq_G_Mean_gamma_list,
seq_Gnorm_gamma_mean, G_norm_mean, G_norm_mean_ordered, net_name, bib_ref, file = file_to_save)
#----
Custom_plot2D(links, nodes, layout, vertex_label_cex = NULL, vertex_size = 3)
#Em construcao
#mostra oque foi savo no RData para debug
load("./RDatas/rand_ml_2_100_30.RData")
load("./RDatas/ants.RData")
gammas
vec_W
iterations
partitions_of_omega
links
nodes
layout
#Seq_G_Mean_gamma_list
seq_Gnorm_gamma_mean
G_norm_mean
G_norm_mean_ordered
net_name
bib_ref
net_multinet = Convert_to_Multinet(nodes, links)
lnum = num_layers_ml(net_multinet)
lnum = num_layers_ml(net_multinet) #numero de camadas da rede
# serve para juntar toas as camadas em uma string soh. Bom para usar como texto
lnames = layers_ml(net_multinet)
lnames2 = ""
for (i in 1:lnum) {
if (i==1) {
lnames2 = paste(lnames[i])
}
else if (i==lnum) {
lnames2 = paste(lnames2, " e ", lnames[i])
}
else{
lnames2 = paste(lnames2, ", ", lnames[i])
}
}
nnum = num_actors_ml(net_multinet, layers = character(0))
cnum = num_edges_ml(net_multinet)
#Monta a coluna de valores e nome da propriedade para montar o df propriedades_da_rede
numbers = c(lnum, lnames2, nnum, cnum)
labels = c("Número de Camadas", "Tipo de conexões", "Número de nós", "Número de conexões")
#Monta a tabela de prorpiedades da rede
propriedades_rede = data.frame(labels, numbers)
names(propriedades_rede) = c("Propriedade", "Valor")
models <- c(evolution_er_ml(20), evolution_er_ml(20), evolution_er_ml(20), evolution_er_ml(20), evolution_er_ml(20))
pr_external <- c(.25,.25,.25,.25,.25)
pr_internal <- c(.25,.25,.25,.25,.25)
dependency <- matrix(c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),5,5)
teste = grow_ml(20, 100, models, pr_internal, pr_external, dependency)
teste
write_ml(teste, file = "teste_write_output.txt", format = "multilayer", layers = character(0),
sep = ',', merge.actors = TRUE, all.actors = FALSE)
teste_igraph = as.igraph(teste, layers = NULL, merge.actors = TRUE, all.actors = FALSE)
nodes_raw
