---
title: "Esqueleto do TF"
author: "Henrique S Requejo"
date: "16/11/2020"
header-includes:
    \AtBeginDocument{\let\maketitle\relax}
output:
  pdf_document:
    latex_engine: xelatex
    number_sections: true
    fig_caption: yes
    includes:
            in_header: preamble.tex
citation_package: biblatex
bibliography: references.bib
biblio-style: apalike
csl: apa.csl
urlcolor: blue
linkcolor: black
fontsize: 12pt
---
<!--

Este código usa o arquivo bats.RData e ants.RData para gerar o documento.
Estes dois arquivos devem estar no mesmo diretório deste .Rmd

Variaveis presentes no .RData:

gammas = vetor com os gammas que foram analisados
vec_W = vetor com os valores de omega utilizados
iterations = numero de iteracoes usados
partitions_of_omega = numero de perticoes de omega (TODO: da pra ser extraido de Vec_W)
links = dataframe dos links, convertido do csv no script motor
nodes = dataframe dos nodes, convertido de um csv no script motor
layout = layout da disposicao da rede, calculado no script motor
seq_Gnorm_gamma_mean = Dataframe com as informaçãoes de Gnorm medio em relacao a omega e gamma
G_norm_mean = Os valores médios de Gnorm do ensaio na mesma ordem de entrada (alfabetico pelo nome do noh)
G_norm_mean_ordered = Os valores médios de Gnorm do ensaio ordenados
net_name = string com o nome da rede
bib_ref = Referencia bibliografica da rede como no biblatex

-->

<!-- As opcoes message = FALSE e warning = FALSE servem para não mostrar As mensagens do console e Warnings no PDF -->
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.pos = 'H', fig.align="center")

```

```{r bibliotecas_e_funcoes_auxiliares}

library(multinet)
library(igraph)
library(plyr)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(kableExtra)
library(akima)
library(plot3D)

source("Aux_functions.R", encoding="utf-8") # importante a opção UTF-8 devido ao acentos nos plots


```



<!-- Sem numero de pagina -->
\pagenumbering{gobble}

\include{Capa.tex}

\pagebreak

\tableofcontents

\pagebreak

<!-- Começa a numeracao de pagina -->
\pagenumbering{arabic} 

# Resumo

Análises de modularidade oriundas da ciência de redes têm sido usadas na Ecologia para operacionalizar conceitos como guilda, grupo funcional e papel funcional. Contudo, essas análises têm sido feitas apenas para redes monocamada, ou seja, que contém só um tipo de interação, portanto, apenas uma classe de arestas. No caso do algoritmo de modularidade Louvain, uma das grandes diferenças entre a tradicional versão monocamada e a nova versão multicamada é a constante de acoplamento. Essa constante, implementada no algoritmo multicamada, torna possível que um mesmo nó pertença a dois módulos diferentes em camadas diferentes. Neste projeto, queremos identificar os nós que resistem ao aumento dessa força de acoplamento entre camadas, permanecendo em mais de um módulo em diferentes camadas ao aumentarmos essa força de acoplamento. Em redes de interações ecológicas, esses nós resistentes devem representar espécies que desempenham papéis funcionais importantes. Por exemplo, animais que são importantes tanto para a polinização, quanto para a dispersão de sementes de duas ou mais famílias de plantas. Para classificar as espécies com relação a sua importância, comparamos a curva do número de módulos aos quais cada nó pertence em função da variação na constante de acoplamento e do parâmetro de resolução. Assim, selecionaremos os nós que apresentam menor decaimento de módulos, ou seja, que permanecem um mais de um módulo mesmo com força de acoplamento entre camadas, considerando diferentes cenários de resolução. Até o momento foram analisadas as redes de interações entre morcegos e plantas [@Mello2019] e de formigas e plantas [@Costa2016]. A próxima etapa é avaliar se ganhamos informação relevante, tanto no nível do nó como no nível dos módulos, na abordagem multicamada em comparação à monocamada. Em seguida, repetiremos essas mesmas análises para redes sintéticas, dessa maneira, poderemos verificar se o método é eficaz em várias redes diferentes. Isso nos permitirá entender melhor o que faz as espécies que eles representam serem mais importantes do que outras para manter funções e serviços ecossistêmicos vitais.

\pagebreak

# Modularidade de Newman e Girvan

A ciência de redes tem sido usada para investigar sistemas ecológicos desde o século XIX [@Ings2018]. Dentre vários avanços, essa abordagem nos permitiu entender melhor como várias espécies afetam umas às outras por meio de interações diretas e indiretas. Esse entendimento  levou a importantes insights sobre a estrutura, função e dinâmica de redes de interações [@Pilosof2017].

Uma forma de obtermos estes insights é olhar para a estrutura de módulos da rede, o que pode revelar alguns padrões escondidos em meio à complexidade de nós e conexões. Estes módulos são compostos por nós mais conectados entre si do que com outros nós de fora do módulo. A capacidade de encontrar e analisar esses módulos pode fornecer ajuda inestimável para entender mais a fundo a estrutura das redes [@Newman2004a]. 

É relativamente fácil identificar módulos em redes pequenas e pouco conectadas. Porém, essa tarefa se torna muito difícil quando analisamos redes mais complexas, com milhares, ou até mesmo milhões, de nós distribuídos em várias camadas. Então, como podemos identificar módulos em redes complexas? Existem muitas formas, como por exemplo métodos aglomerativos, divisivos, baseados em cliques e de otimização de modularidade. Neste projeto vamos focar na otimização de modularidade.

Para otimizarmos a modularidade, precisamos de uma métrica que indique se uma específica divisão da rede em módulos é melhor do que outra, para então buscar qual seria a melhor divisão de módulos possível. Uma métrica para medir a qualidade da modularidade de redes foi definida pela primeira vez por Newman e Girvan [@Newman2004a] como:

\begin{equation} \label{eq:mod_basica}
    Q = \sum^{k}_{i=1}(e_{ii}-a^2_i)
\end{equation} 

Onde $e_{ii}$ representa a fração das conexões observadas dentro do módulo $i$ em relação ao total de conexões dentro da rede e $a^2_i$ representa a quantidade esperada de conexões no módulo $i$.

Para determinar a proporção de conexões dentro dos módulos, suponha que temos uma uma possível divisão de módulos dentro da rede representada pela matriz de adjacência $A_{ij}$,  seja $C_i$ o módulo  que o nó $i$ está contido, então, a fração de conexões que conectam os vértices que estão dentro de um mesmo módulo é:

\begin{equation} \label{eq:fracao_conect}
    \frac{\sum_{ij} A_{ij} \delta (c_i, c_j)}{\sum_{ij} A_{ij}} = \frac{1}{2m} \sum_{ij} A_{ij} \delta (c_i, c_j) 
\end{equation} 


Onde $\delta$ é o delta de kronecker, que retorna o valor 1 caso $c_i = c_j$ e zero caso contrário; a variável $m$ representa o número total de conexões da rede. Falta agora definirmos uma forma de medir a quantidade esperada de nós dentro do módulo. Se conectarmos os vértices de forma aleatória, preservando os graus de cada nó, representados pela variável $k$, temos que a probabilidade de existir uma conexão entre os nós $i$ e $j$ é $k_i k_j / 2m$ . Dessa forma, temos que a modularidade descrita acima pode ser reescrita de uma forma mais operacional [@Blondel2008] como:

\begin{equation} \label{eq:blondel}
    Q = \frac{1}{2m} \sum_{ij} (A_{ij} - \frac{k_i k_j}{2m}) \delta(c_i c_j)
\end{equation}

Os valores da modularidade descrita acima podem variar entre zero e 1.

\pagebreak

# Método Louvain para otimização de modularidade

Se dividirmos a rede em módulos e o valor de modularidade definido por Newman e Girvan for alto, temos que a divisão de módulos escolhida é boa. Dessa forma, basta dividirmos a rede em diferentes módulos visando maximizar o valor da modularidade Newman-Girvan. Porém, esta não é uma tarefa fácil, já que a otimização de modularidade é um problema NP-difícil [@Brandes2008]. Um problema NP (Non Deterministic Polynomial Time) é um problema que leva um tempo exponencial para ser resolvido, por exemplo $O(2^N)$. Estes problemas NP demoram muito para serem computados, por exemplo, caso o problema possua uma complexidade exponencial $O(2^N)$ e $N$ (tamanho da entrada) seja igual a 100, o programa demoraria um tempo maior que a idade do universo para ser resolvido. Um problema NP-difícil é um problema que é ao menos tão difícil quanto um problema NP-completo.

Esta dificuldade computacional em dividir redes em módulos significativos motivou a procura por métodos heurísticos para encontrar agrupamentos que apresentam um alto valor de modularidade com uma complexidade razoável. Este é o caso do método Louvain [@Blondel2008],  que parece funcionar em um tempo $O(M)$, onde $M$ representa o número total de conexões da rede, ou seja, é resolvido em tempo polinomial, neste caso, linear com relação ao número de nós da rede. Essa complexidade computacional permite que redes de grande escala possam ser analisadas em tempo razoável, além de ser simples e de fácil implementação.

A implementação do algoritmo Louvain consiste de dois passos básicos, descritos em detalhe por @Blondel2008. O primeiro passo agrupa os nós em módulos de forma individual, favorecendo otimizações locais de modularidade. O segundo passo transforma a rede original em uma nova rede simplificada, cujo os novos nós são os módulos do passo anterior. As conexões entre estes novos nós correspondem à soma das conexões entre os módulos e cada nó agora tem um laço (conexão que liga um nó a ele mesmo) cujo o peso é a soma das conexões dentro do módulo correspondente. Esses dois passos são repetidos até que não exista mais aumento no valor da modularidade. A figura \ref{fig:algoritmo_Louvain} ilustra o algoritmo.

\begin{figure}[H] 
\centering
\includegraphics[width=0.8\textwidth]{./Figuras/Algoritmo_Louvain.png}
\caption{Extraído de Blondel et al. (2008). Visualização dos passos do algoritmo Louvain. Cada passo é feito em duas fases: uma onde a modularidade é otimizada permitindo somente mudanças locais de módulo e uma onde os módulos encontradas são agregadas e uma nova rede de módulos é construída.}
\label{fig:algoritmo_Louvain}
\end{figure}

Apesar deste ser um algoritmo ganancioso, ele apresenta boa detecção de módulos que possuem sentido quando aplicados em redes reais [@Blondel2008;@Meunier2009;@Zhang2010] e é mais rápido que outros algoritmos similares, como mostrado na tabela \ref{tab:tabela_blondel}, extraída de @Blondel2008. Outra vantagem do método é que não precisamos saber previamente o número de módulos que a rede deve ser dividida.


\begin{table}[h!]
  \caption{Extraído de Blondel et al. (2008). Comparação entre os tempos computacionais dos algoritmos Clauset et al (CNM), Pons e Latapy (PL), Wakita e Tsurumi (WT) e Louvain (LV). Os resultados mostram a modularidade obtida e o tempo computacional para cada rede/método. Células em branco representam tempos computacionais maiores que 24 horas.}
  \label{tab:tabela_blondel}
  \centering
  \resizebox{\textwidth}{!}{ 
\begin{tabular}{ | c | c | c | c | c | c | c | c | }
\hline
	 & \textbf{Karate} & \textbf{Arxiv} & \textbf{Internet} & \textbf{Web nd.edu} & \textbf{Telefone} & \textbf{Web uk2005} & \textbf{WebBase 2001} \\ \hline
	Nós / Conexões & 34/77 & 9k/24k & 70k/351k & 325k/1M & 2.04M/5.4M & 39M/783M & 118M/1B \\ \hline
	CNM & 0.38/0s & 0.772/3.6s & 0.692/799s & 0.927/5034s & - & - & - \\ \hline
	PL & 0.42/0s & 0.752/3.3s & 0.729/575s & 0.895/6666s & - & - & - \\ \hline
	WT & 0.42/0s & 0.761/0.7s & 0.667/62s & 0.898/248s & 0.553/367s & - & - \\ \hline
	LV & 0.42/0s & 0.813/0s & 0.781/1s & 0.935/3s & 0.76/44s & 0.935/3s & 0.984/152min \\ \hline
\end{tabular}
}
\end{table}

Por outro lado, o método Louvain também apresenta limitações [@Good2010]. Dentre as mais expressivas estão o limite de resolução, o problema de degeneração e o fato de o algoritmo não ser determinístico. O problema de limite de resolução ocorre pois o algoritmo pode não parar nos módulos “intuitivos” devido a uma segunda passagem pela modificação dos módulos. Já o problema de degeneração ocorre pois podem existir muitas soluções com valor de modularidade próximos do máximo global, nesses casos é muito difícil encontrar o máximo global e de realmente afirmar se o máximo global possui significância científica maior que os máximos locais com valores de modularidade similares.

Uma característica interessante do método é que não é possível, pela própria natureza do algoritmo, que um mesmo nó esteja presente em diferentes módulos, essa sobreposição de módulos é chamada dentro da área de modularidade de redes de \textit{overlapping communities}. Porém, ao adaptarmos a forma de calcular a modularidade para multicamada [@Mucha2010], existe a possibilidade de que um mesmo nó pertença a diferentes módulos em diferentes camadas ao ajustarmos um parâmetro de entrada. Esta diferença é interessante e será usada para tentar encontrar espécies-chave que são boas conectoras entre grupos diferentes em camadas diferentes.

\pagebreak

# Modularidade Multicamada

Apesar do amplo estudo de redes para compreensão de sistemas e tomada de decisão, estas redes são normalmente estudadas de forma desconexa de outras redes ou então agregando-se várias redes em uma única rede [@Pilosof2017]. Uma maneira de aumentarmos as informações usadas no estudo de redes é usar redes multicamada [@Pilosof2017]. Quando usadas para representar sistemas ecológicos,  as redes multicamada podem ter suas camadas definidas através de interações de diferentes tipos, ou que acontecem em diferentes localidades ou estações do ano, por exemplo [@Pilosof2017].

No caso deste projeto, a rede em foco é a rede multicamada onde as camadas são definidas pelo tipo de interação, ou seja, todos os nós estão presentes em todas as camadas e apenas o tipo de ligação (interações) entre os nós é o que muda em cada camada. Assim, nesse tipo de rede há duas classes maiores de arestas: intracamada, que conecta nós dentro de uma camada, e intercamada, que conecta um mesmo nó entre duas camadas. Este tipo de rede é chamada de \textit{multiplex} [@Mucha2010], que é uma subdivisão da grande categoria definida como redes multicamada.

Redes multiplex também podem ter sua modularidade analisada pelo método Louvain [@Mucha2010]. Essa adaptação consiste basicamente na mudança da forma como a função da modularidade é calculada, incluindo um parâmetro $\omega$ que controla o acoplamento entre as diferentes camadas da rede. Há também o parâmetro de resolução $\omega$, que pode enviesar a tendência do algoritmo em encontrar módulos de escalas menores ou maiores. A generalização da equação de modularidade [@Mucha2010] é dada por:

\begin{equation} \label{eq:1}
Q^{M} = \frac{1}{\mu} \sum_{ij\alpha\beta} \left[ \left(A_{i\alpha,j\alpha} - \gamma_{\alpha} \frac{k_{i\alpha} k_{j\alpha}}{2m_\alpha} \right) \delta_{\alpha,\beta} + \omega A_{i\alpha,j\beta} \delta_{ij} \right] \delta(c_{i\alpha}, c_{j \beta})
\end{equation}

Onde $\delta$ é o delta de kronecker, que retorna o valor 1 caso $c_{i\alpha} = c_{j \beta}$ e zero caso contrário; a variável $m$ representa a soma de do grau de cada nó na camada $\alpha$; $A_{i\alpha,j\alpha}$ é a matriz de adjacência na camada $\alpha$; $A_{i\alpha,j\beta}$ é a matriz de adjacência entre camadas; $k_{i\alpha}$ representa o grau do nó $i$ na camada $\alpha$ e $\mu = \sum_{i,j, \alpha}A_{i\alpha,j\alpha} + \omega \sum_{i,\alpha,\beta} A_{i\alpha,j\beta}$. Note que se utilizarmos $\omega = 0$ e $\gamma = 1$, a equação de modularidade generalizada (eq. \ref{eq:1}) é proporcional a média da modularidade monocamada [@Newman2004a; @Newman2004b] de cada camada. Isto também está descrito em @Bianconi2018, pg. 147-148:

\begin{equation} \label{eq:2}
Q^{M} = \frac{1}{\mu} \sum_{\alpha} \frac{1}{2m_\alpha} \sum_{ij} \left(A_{i\alpha,j\alpha} - \gamma_{\alpha} \frac{k_{i\alpha} k_{j\alpha}}{2m_\alpha} \right) \delta(c_{i\alpha}, c_{j\alpha}) \end{equation}

# Parâmetros de acoplamento ($\omega$) e resolução ($\gamma$) na prática

Como a escolha dos parâmetros de resolução e acoplamento é arbitrária, ficam as perguntas: qual o melhor valor para aplicar na minha rede? Existe apenas um único melhor valor ou depende do que estou querendo enxergar? Quais são os efeitos na prática quando variamos $\gamma$ e $\omega$? Com o objetivo de responder essas perguntas e auxiliar na escolha dos valores de $\gamma$ e $\omega$, vamos analisar o que ocorre quando variamos esses parâmetros.

O parâmetro $\omega$ está contido no intervalo (0,1), onde zero representa o desacoplamento total das camadas (cada camada é tratada como uma rede individual) e a modularidade final é a média da modularidade de cada camada, e 1 representa o acoplamento máximo, o que faz com que a rede multiplex se comporte como uma rede monocamada. Na prática, isso significa que, quando aumentamos os valores da constante de acoplamento $\omega$, aumentamos o peso das conexões intercamada [@Mucha2010], isso faz com que as camadas tenham maior influência umas sobre as outras, favorecendo a formação de módulos multicamada. Quando diminuímos $\omega$, o contrário ocorre, o que favorece a formação de módulos monocamada.

O parâmetro de resolução foi introduzido por @Reichardt2006 para avaliar redes monocamada e foi propagado para a modularidade generalizada multicamada [@Mucha2010], funcionando da mesma forma. De uma forma geral, se $\gamma_2 > \gamma_1$, os módulos encontrados com $\gamma_2$ possuem menos nós (módulos menores) e são mais numerosos (maior quantidade de módulos). Os módulos encontrados com $\gamma_2$ podem ser submódulos dos obtidos usando $\gamma_1$, mas nem sempre é o caso [@Reichardt2006]. Lembrando que $0 \leq \gamma \leq \infty$. Porém, não faz sentido aumentarmos $\gamma$ para valores muito altos, já que existe um limite onde os módulos se tornam tão pequenos que cada módulo passa a ter apenas um nó.

Vamos usar a rede multiplex Famílias de Florença [@Kent1978] para ilustrar graficamente o que ocorre quando variamos os parâmetros $\omega$ e $\gamma$. Essa rede foi escolhida por ser uma rede multiplex pequena, o que facilita a visualização. A figura \ref{fig:Mosaico1} mostra a distribuição visual dos módulos sobre as duas camadas da rede para diferentes valores de $\omega$ e $\gamma$.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{./Figuras/Mosaico_edit.png}
    \caption{Módulos formados usando diferentes valores de acoplamento $\omega$ e resolução $\gamma$. Valores de $\omega$ variam no eixo y e valores de $\gamma$ variam no eixo x.}
    \label{fig:Mosaico1}
\end{figure}

\pagebreak

Quanto maiores o os valores de $\gamma$ e menores os valores de $\omega$, menores e mais numerosos são os módulos e vice-versa. A figura \ref{fig:Mosaico2} mostra o número de módulos para a rede exemplo Famílias de Florença, onde podemos ver que ocorre o previsto na teoria.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{./Figuras/Mosaico_numero_de_modulos_edit.png}
    \caption{Número de módulos totais da rede para diferentes valores de acoplamento $\omega$ e resolução $\gamma$. Valores de $\omega$ variam no eixo y e valores de $\gamma$ variam no eixo x.}
    \label{fig:Mosaico2}
\end{figure}

\pagebreak

Mas afinal, quais valores devo escolher para os parâmetros? A resposta mais correta é: depende. Depende do queremos enxergar e qual insigth queremos obter. Por exemplo, se quisermos verificar quais são os “grandes módulos” da rede devemos usar um valor de $\gamma$ mais baixo, caso quisermos encontrar módulos menores (mais “íntimos”) ou submódulos dos “grandes módulos” obtidos com um $\gamma$ mais baixo, um $\gamma$ maior seria o mais indicado.

Se quisermos que as conexões de uma camada influenciem mais sobre a outra camada, devemos usar um $\omega$ mais alto, coso contrário, melhor usar um $\omega$ mais baixo. Por exemplo, na rede de morcegos-planta [@Mello2019], onde existem duas camadas, uma de nectarívoria e outra de frugívoria. Se quisermos encontrar módulos onde existam morcegos com dietas similares no geral, um $\omega$ mais alto é recomendado, pois, temos a frugívoria e nectarívoria com alta influência uma sobre a outra no cálculo dos módulos. Caso quisermos separar morcegos com uma preferência maior por flores, por frutos ou que tenham uma dieta equilibrada, podemos usar um $\omega$ menor, já que assim existe a tendência dos módulos se formarem pesando mais as interações dentro de cada camada da rede, fazendo com que os morcegos estejam em grupos que priorizam mais a nectarívoria ou a frugivoría ou até mesmo que possuem interações equilibradas entre camadas (estão em dois grupos em camadas diferentes).

Interpretação, conhecimento específico da área que a rede representa e saber o que queremos enxergar são os fatores principais para a escolha dos valores de $\omega$ e $\gamma$

Caso quisermos apenas obter uma distribuição de módulos confiável sem a necessidade de interpretação, podemos escolher um valor de $\omega$ e $\gamma$ que maximiza a modularidade. Os valores de $\omega$ e $\gamma$ que maximizam a modularidade diferem para cada rede. A figura \ref{fig:Mosaico3} mostra os valores da modularidade para diferentes valores de $\omega$ e $\gamma$ da rede exemplo Famílias de Florença.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{./Figuras/Mosaico_modularidade_edit.png}
    \caption{Valor da modularidade para diferentes valores de acoplamento $\omega$ e resolução $\gamma$. Valores de $\omega$ variam no eixo y e valores de $\gamma$ variam no eixo x.}
    \label{fig:Mosaico3}
\end{figure}

Com a resolução do ensaio feito, os valores mais indicados para a rede famílias de florença seriam $\omega = 0.75$ e $\gamma = 1.5$. Para valores mais precisos, basta aumentar as partições de $\gamma$ e $\omega$ ou refinar os valores de $\gamma$ e $\omega$ em torno dos máximos obtidos no ensaio anterior.

Também existe a possibilidade de que os valores de modularidade fiquem muito próximos uns dos outros. Nesse caso, é comum que os módulos fiquem muito similares entre si, então, é possível escolher qualquer um dos valores de $\omega$ e $\gamma$. Caso os módulos fiquem muito diferentes entre si (um caso mais raro), uma interpretação de um especialista na área que a rede está retratando é fundamental.

\clearpage


# Variável $G$ e $G_{norm}$

## Variável G

A variável G representa o número de módulos que um determinado nó pertence. Como o algoritmo Louvain não permite que um mesmo nó participe de mais de um módulo dentro de uma mesma camada, G é uma variável discreta inteira que possui o mínimo de 1 e o máximo igual ao número de camadas da rede estudada. G possui valores bem definidos nos extremos, se $\omega = 0 \Rightarrow G = 1$ e se $\omega = 0 \Rightarrow G = \text{ número total de camadas da rede}$. Entre estes valores de $\omega$ o comportamento de G é variado, mas tende a cair conforme a força de acoplamento $\omega$ aumenta. O comportamento do decaimento de G em relação a $\omega$ é diferente para cada nó da rede, alguns nós resistem e permanecem em mais de um módulo ao aumentarmos $\omega$, já outros rapidamente passam a pertencer a apenas um módulo ao aumentarmos $\omega$. A figura \ref{fig:Figura_G} ilustra o comportamento de diferentes nós ao aumentarmos $\omega$. A figura \ref{fig:Exemplo_decai} mostra um exemplo de curva de decaimento de G em relação a $\omega$.

\begin{figure}[H] 
\centering
\includegraphics[width=0.8\textwidth]{./Figuras/Figura_G.png}
\caption{Esquema ilustrativo do que ocorre com alguns nós ao aumentarmos o parâmetro $\omega$. Para valores de $\omega$ baixos, vemos que os nós A e B estão em módulos diferentes em camadas diferentes. Ao aumentarmos a força de acoplamento $\omega$, o nó A passa a pertencer ao módulo verde tanto na camada superior como na camada inferior, já o nó B resiste e permanece no módulo azul na camada superior e no módulo verde na camada inferior. Se aumentarmos ainda mais a força de acoplamento $\omega$, em algum momento o nó B acaba cedendo e passa a pertencer a apenas um módulo nas duas camadas.}
\label{fig:Figura_G}
\end{figure}

\begin{figure}[H] 
\centering
\setlength{\fboxsep}{0pt}%
\setlength{\fboxrule}{0.25pt}%
\fbox{\includegraphics[width=0.7\textwidth]{./Figuras/Exemplo_decai.png}}
\caption{Exemplo hipotético de decaimentos de G (módulos que o nó pertence em diferentes camadas) em relação ao parâmetro $\omega$ (constante de acoplamento) esperados. O nó representado pela cor vermelha possui um decaimento rápido de G, portanto, representa uma espécie pouco conectiva do ponto de vista da rede multicamada como um todo. O contrário ocorre com a espécie representada pelo nó azul.}
\label{fig:Exemplo_decai}
\end{figure}

Como o algoritmo Louvain não é determinístico (pode retornar diferentes resultados a cada compilação) e a variável G é inteira e discreta, para termos uma maior confiabilidade precisamos repetir o processo várias vezes para cada valor de $\omega$ e extrair uma média de G para cada nó. Assim o valor médio de G é dado por:

\begin{equation} \label{eq:3}
    \overline{G_{\omega}} = \frac{1}{I} \sum_{i=1}^{I} G_{i}
\end{equation}

Onde $I$ se refere ao número de iterações.

Repetindo isso para diferentes valores de $\omega$, teremos uma curva de decaimento $\overline{G}$ por $\omega$.

Podemos agora repetir esse processo para diferentes valores de $\gamma$, assim vamos obter diferentes curvas $\overline{G}$ por $\omega$ para cada valor de $\gamma$.

## Variável G$_{norm}$

Para facilitar a classificação dos nós de acordo com sua curva $\overline{G}$ por $\omega$ por $\gamma$, toda a família de curvas será resumida em uma única variável para cada nó, normalizada pela média. Chamaremos essa variável de $G_{norm}$, definida na equação \ref{eq:4}.

\begin{equation} \label{eq:4}
    G_{norm} = \frac{\sum_{j=1}^{P_2} \sum_{i = 1}^{P_1} \overline{G}_{i,j}}{\frac{1}{N} \sum_{k=1}^{N} \sum_{j=1}^{P_2} \sum_{i = 1}^{P_1} \overline{G}_{i,j,k}}
\end{equation}

Onde $P_1$, $P_2$ são o número de partições de $\omega$ e $\gamma$; $N$ é u número de nós na rede; $i$, $j$ são os índices de $\overline{G}$ dentro de $\omega$, $\gamma$; e $k$ é o índice do nó na rede (número de identificação do nó).

\pagebreak

```{r leitura_dos_dados_morcego}
load("./RDatas/bats.RData")
```

<!-- modifcar o 'net_x' para corresponder com as figuras -->
# Visão geral da rede `r net_name`

<!-- Usa as variaveis nodes e links para gerar a tabela comk os numeros da rede -->
```{r Propriedades_Rede}

net_multinet = Convert_to_Multinet(nodes, links)

lnum = num_layers_ml(net_multinet) #numero de camadas da rede

# serve para juntar toas as camadas em uma string soh. Bom para usar como texto
lnames = layers_ml(net_multinet)
lnames2 = ""
for (i in 1:lnum) {
  if (i==1) {
    lnames2 = paste(lnames[i])
  }
  else if (i==lnum) {
    lnames2 = paste(lnames2, " e ", lnames[i])
  }
  else{
    lnames2 = paste(lnames2, ", ", lnames[i])
  }
}

nnum = num_actors_ml(net_multinet, layers = character(0))

cnum = num_edges_ml(net_multinet)

#Monta a coluna de valores e nome da propriedade para montar o df propriedades_da_rede
numbers = c(lnum, lnames2, nnum, cnum)

labels = c("Número de Camadas", "Tipo de conexões", "Número de nós", "Número de conexões")

#Monta a tabela de prorpiedades da rede
propriedades_rede = data.frame(labels, numbers)
names(propriedades_rede) = c("Propriedade", "Valor")

```

<!-- Usa as variavei geradas no code chunk acima para preencher o texto -->
A rede `r net_name` [@`r bib_ref`] possui `r lnum` camadas (`r lnames2`), `r nnum` nós e `r cnum` conexões. A tabela \ref{tab:1} mostra o resumo das propriedades da rede. A figura \ref{fig:fig1} apresenta uma visão geral da rede.

```{r Tabela_Prop_Rede, col.names = NULL}
kable(propriedades_rede, "latex", booktabs = T, caption = paste("\\label{tab:1}Propriedades da rede ", net_name)) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

<!-- links, nodes e layout sao variaveis vindas do .RData -->
```{r Figura_Overview, fig.cap=paste(fig.cap="\\label{fig:fig1}Visão geral da rede ", net_name, ".")}
#calcula um layout (igraph) e plota o grafo usando a funcao aux CustomPlot----
Custom_plot2D(links, nodes, layout, vertex_label_cex = NULL, vertex_size = 3) # TODO: melhorar o custom plot depois
```


# Resultados da rede `r net_name`
## Distribuição de $\mathbf{G_{norm}}$

A variável $G$ foi calculada para `r partitions_of_omega` partições de $\omega$, ou seja, o tamanho do passo dado dentro de $\omega$ foi de `r 1/partitions_of_omega`. O processo foi repetido para `r length(gammas)` partições de $\gamma$, com $\gamma$ começando em `r min(gammas)`, com passos de `r (gammas[2] - gammas[1])` até um $\gamma$ máximo de `r max(gammas)`. O cálculo de $\overline{G}$ foi feito usando `r iterations` iterações. A tabela \ref{tab:2} resume os parâmetros de execução do código e a figura \ref{fig:fig2} mostra a distribuição dos valores de $G_{norm}$ médio obtidos.

```{r Parametros_Execucao}
numbers = c(iterations, partitions_of_omega)

labels = c("Iterações", "Partições de omega")

propriedades_rede = data.frame(labels, numbers)
names(propriedades_rede) = c("Parâmetro", "Valor")
kable(propriedades_rede, "latex", booktabs = T, caption = "\\label{tab:2}Parâmetros de execucao") %>% kable_styling(latex_options = c("striped", "hold_position"))
```


```{r Distribuicao_Gnorm, fig.cap=paste(fig.cap="\\label{fig:fig2}Distribuição de $G_{norm}$ médio da rede ", net_name, ".")}
G_norm_dristrib_plot(G_norm_mean_ordered)
```

## Variação de $\mathbf{\overline{G}}$ por $\boldsymbol{\omega}$

Como temos dados em 3 dimensões ($\overline{G}$, $\omega$, $\gamma$) temos algumas formas diferentes para apresentar os valores de $\overline{G}$ em relação a $\omega$ e $\gamma$, não sei dizer se devemos usar uma delas, as três ou alguma outra. A figura \ref{fig:1a} mostra curvas de decaimento de $\overline{G}$ por $\omega$ para diferentes nós com diferentes valores de $G_{norm}$ e para diferentes valores de $\gamma$. A figura \ref{fig:1a.1} mostra a superfície 3D formada por $\overline{G}$ em relação a $\omega$ e $\gamma$. A figura \ref{fig:1a.2} mostra a mesma superfície da figura \ref{fig:1a.1} mas no formato de mapa de calor.

```{r select_exemple_nodes}
#seleciona quatro noh e guarda suas curvas de decaimento G em relacao a w e gamma usando funcao auxiliar
selection = Select_Example_Nodes(G_norm_mean_ordered)
plots_2D = list() #armazena os plots 2D que serao plotados
for (i in 1:length(selection)) {
  #plota a familia de curvas G para cada gamma de um no escolhido----
  chosen_node = names(selection[i])
  plots_2D[[i]] = G_curves_for_different_gammas(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
```

```{r decaimentos_ilustrativos, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:1a}Exemplos de curvas do decaimento de $\\overline{G}$ em relação a $\\omega$ e $\\gamma$ para diferentes valores de $\\gamma$ da rede ", net_name, ". (a) Curvas de $\\overline{G}$ da especie com maior valor de $G_{norm}$ da rede. (b) Segundo maior valor de $G_{norm}$. (c) Valor de $G_{norm}$ mais proximo da média geral da rede. (d) Curvas de $\\overline{G}$ referente a uma espécie com valor de $G_{norm}$ abaixo da média da rede."), fig.subcap=c(paste(names(selection[1]),". $G_{norm} =$", format(round(selection[1], 3), nsmall = 3)), paste(names(selection[2]),". $G_{norm} =$", format(round(selection[2], 3), nsmall = 3)), paste(names(selection[3]),". $G_{norm} =$", format(round(selection[3], 3), nsmall = 3)), paste(names(selection[4]),". $G_{norm} =$", format(round(selection[4], 3), nsmall = 3))), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.nrow = 2}

for (i in 1:length(selection)) {
  print(plots_2D[[i]])
}
```


```{r decaimentos_ilustrativos_sup_3D, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:1a.1}Exemplos de superfícies do decaimento de $\\overline{G}$ em relação a $\\omega$ e $\\gamma$ para diferentes valores de $\\gamma$ da rede ", net_name, ". (a) Superfície de $\\overline{G}$ da especie com maior valor de $G_{norm}$ da rede. (b) Segundo maior valor de $G_{norm}$. (c) Valor de $G_{norm}$ mais proximo da média geral da rede. (d) Superfície de $\\overline{G}$ referente a uma espécie com valor de $G_{norm}$ abaixo da média da rede."), fig.subcap=c(paste(names(selection[1]),". $G_{norm} =$", format(round(selection[1], 3), nsmall = 3)), paste(names(selection[2]),". $G_{norm} =$", format(round(selection[2], 3), nsmall = 3)), paste(names(selection[3]),". $G_{norm} =$", format(round(selection[3], 3), nsmall = 3)), paste(names(selection[4]),". $G_{norm} =$", format(round(selection[4], 3), nsmall = 3))), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.nrow = 2}

for (i in 1:length(selection)) {
  chosen_node = names(selection[i])
  Plot_G_gamma_omega_suf_3D(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
```


```{r decaimentos_ilustrativos_heatmap, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:1a.2}Exemplos de mapas de calor do decaimento de $\\overline{G}$ em relação a $\\omega$ e $\\gamma$ para diferentes valores de $\\gamma$ da rede ", net_name, ". (a) Mapa de calor de $\\overline{G}$ da especie com maior valor de $G_{norm}$ da rede. (b) Segundo maior valor de $G_{norm}$. (c) Valor de $G_{norm}$ mais proximo da média geral da rede. (d) Mapa de calor de $\\overline{G}$ referente a uma espécie com valor de $G_{norm}$ abaixo da média da rede."), fig.subcap=c(paste(names(selection[1]),". $G_{norm} =$", format(round(selection[1], 3), nsmall = 3)), paste(names(selection[2]),". $G_{norm} =$", format(round(selection[2], 3), nsmall = 3)), paste(names(selection[3]),". $G_{norm} =$", format(round(selection[3], 3), nsmall = 3)), paste(names(selection[4]),". $G_{norm} =$", format(round(selection[4], 3), nsmall = 3))), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.nrow = 2}

for (i in 1:length(selection)) {
  chosen_node = names(selection[i])
  Plot_G_gamma_omega_heat_3D(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
```

## Seleção das espécies com maior $\mathbf{G_{norm}}$.

```{r define_Gnorm_treshold}
G_threshold = 1.35
size1 = 3 #tamanho dos nos abixo do G_threshold
size2 = 3*size1 #tamanho dos valores acima de G_threshold

```


A figura \ref{fig:2a} e a tabela \ref{tab:3} mostram as espécies com valor de $G_{norm}$ acima de `r G_threshold`, ou seja, aquelas com decaimento de $G$ mais lento da rede `r net_name`.

```{r define_aspecto}
if (lnum < 4) {
  asp = 0.6
}else{
  asp = 1
}
```


```{r fig-sub2, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:2a}Espécies com G$_{norm}$ maiores que ", G_threshold, "em destaque de tamanho e cor."), fig.asp=asp, nrow = 1, ncol = 3}

Custom_plot2D_destaque_palette(G_norm_mean, links, nodes, layout, size1, size2)

```


```{r, tabela_decimento_lento}
selected_nodes = sort(G_norm_mean[which(G_norm_mean > G_threshold)], decreasing = TRUE)
selected_nodes_df = data.frame(names(selected_nodes), format(round(selected_nodes, 3), nsmall = 3))
names(selected_nodes_df) = c("Espécie", "$G_{norm}$")
rownames(selected_nodes_df) = NULL

kable(selected_nodes_df, "latex", booktabs = T, caption = paste("\\label{tab:3}Espécies com valores de $G_{norm}$ maiores que", G_threshold), escape = FALSE) %>% kable_styling(latex_options = c("striped", "hold_position"))
```


```{r leitura_dos_dados_formigas}
load("./RDatas/ants.RData")
```

\pagebreak

<!-- modifcar o 'net_x' para corresponder com as figuras -->
# Visão geral da rede `r net_name`

<!-- Usa as variaveis nodes e links para gerar a tabela comk os numeros da rede -->
```{r Propriedades_Rede_b}

net_multinet = Convert_to_Multinet(nodes, links)

lnum = num_layers_ml(net_multinet) #numero de camadas da rede

# serve para juntar toas as camadas em uma string soh. Bom para usar como texto
lnames = layers_ml(net_multinet)
lnames2 = ""
for (i in 1:lnum) {
  if (i==1) {
    lnames2 = paste(lnames[i])
  }
  else if (i==lnum) {
    lnames2 = paste(lnames2, " e ", lnames[i])
  }
  else{
    lnames2 = paste(lnames2, ", ", lnames[i])
  }
}

nnum = num_actors_ml(net_multinet, layers = character(0))

cnum = num_edges_ml(net_multinet)

#Monta a coluna de valores e nome da propriedade para montar o df propriedades_da_rede
numbers = c(lnum, lnames2, nnum, cnum)

labels = c("Número de Camadas", "Tipo de conexões", "Número de nós", "Número de conexões")

#Monta a tabela de prorpiedades da rede
propriedades_rede = data.frame(labels, numbers)
names(propriedades_rede) = c("Propriedade", "Valor")

```

<!-- Usa as variavei geradas no code chunk acima para preencher o texto -->
A rede `r net_name` [@`r bib_ref`] possui `r lnum` camadas (`r lnames2`), `r nnum` nós e `r cnum` conexões. A tabela \ref{tab:1a} mostra o resumo das propriedades da rede. A figura \ref{fig:fig1a} apresenta uma visão geral da rede.

```{r Tabela_Prop_Rede_b, col.names = NULL}
kable(propriedades_rede, "latex", booktabs = T, caption = paste("\\label{tab:1a}Propriedades da rede ", net_name)) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

<!-- links, nodes e layout sao variaveis vindas do .RData -->
```{r Figura_Overview_b, fig.cap=paste(fig.cap="\\label{fig:fig1a}Visão geral da rede ", net_name, ".")}
#calcula um layout (igraph) e plota o grafo usando a funcao aux CustomPlot----
Custom_plot2D(links, nodes, layout, vertex_label_cex = NULL, vertex_size = 3) # TODO: melhorar o custom plot depois
```


# Resultados da rede `r net_name`
## Distribuição de $\mathbf{G_{norm}}$

A variável $G$ foi calculada para `r partitions_of_omega` partições de $\omega$, ou seja, o tamanho do passo dado dentro de $\omega$ foi de `r 1/partitions_of_omega`. O processo foi repetido para `r length(gammas)` partições de $\gamma$, com $\gamma$ começando em `r min(gammas)`, com passos de `r (gammas[2] - gammas[3])` até um $\gamma$ máximo de `r max(gammas)`. O cálculo de $\overline{G}$ foi feito usando `r iterations` iterações. A tabela \ref{tab:2a} resume os parâmetros de execução do código e a figura \ref{fig:fig2a} mostra a distribuição dos valores de $G_{norm}$ médio obtidos.

```{r Parametros_Execucao_b}
numbers = c(iterations, partitions_of_omega)

labels = c("Iterações", "Partições de omega")

propriedades_rede = data.frame(labels, numbers)
names(propriedades_rede) = c("Parâmetro", "Valor")
kable(propriedades_rede, "latex", booktabs = T, caption = "\\label{tab:2a}Parâmetros de execucao") %>% kable_styling(latex_options = c("striped", "hold_position"))
```


```{r Distribuicao_Gnorm_b, fig.cap=paste(fig.cap="\\label{fig:fig2a}Distribuição de $G_{norm}$ médio da rede ", net_name, ".")}
G_norm_dristrib_plot(G_norm_mean_ordered)
```

## Variação de $\mathbf{\overline{G}}$ por $\boldsymbol{\omega}$

Como temos dados em 3 dimensões ($\overline{G}$, $\omega$, $\gamma$) temos algumas formas diferentes para apresentar os valores de $\overline{G}$ em relação a $\omega$ e $\gamma$, não sei dizer se devemos usar uma delas, as três ou alguma outra. A figura \ref{fig:1b} mostra curvas de decaimento de $\overline{G}$ por $\omega$ para diferentes nós com diferentes valores de $G_{norm}$ e para diferentes valores de $\gamma$. A figura \ref{fig:1b.1} mostra a superfície 3D formada por $\overline{G}$ em relação a $\omega$ e $\gamma$. A figura \ref{fig:1b.2} mostra a mesma superfície da figura \ref{fig:1b.1} mas no formato de mapa de calor.

```{r select_exemple_nodes_b}
#seleciona quatro noh e guarda suas curvas de decaimento G em relacao a w e gamma usando funcao auxiliar
selection = Select_Example_Nodes(G_norm_mean_ordered)
plots_2D = list() #armazena os plots 2D que serao plotados
for (i in 1:length(selection)) {
  #plota a familia de curvas G para cada gamma de um no escolhido----
  chosen_node = names(selection[i])
  plots_2D[[i]] = G_curves_for_different_gammas(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
```

```{r decaimentos_ilustrativos_b, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:1b}Exemplos de curvas do decaimento de $\\overline{G}$ em relação a $\\omega$ e $\\gamma$ para diferentes valores de $\\gamma$ da rede ", net_name, ". (a) Curvas de $\\overline{G}$ da especie com maior valor de $G_{norm}$ da rede. (b) Segundo maior valor de $G_{norm}$. (c) Valor de $G_{norm}$ mais proximo da média geral da rede. (d) Curvas de $\\overline{G}$ referente a uma espécie com valor de $G_{norm}$ abaixo da média da rede."), fig.subcap=c(paste(names(selection[1]),". $G_{norm} =$", format(round(selection[1], 3), nsmall = 3)), paste(names(selection[2]),". $G_{norm} =$", format(round(selection[2], 3), nsmall = 3)), paste(names(selection[3]),". $G_{norm} =$", format(round(selection[3], 3), nsmall = 3)), paste(names(selection[4]),". $G_{norm} =$", format(round(selection[4], 3), nsmall = 3))), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.nrow = 2}

for (i in 1:length(selection)) {
  print(plots_2D[[i]])
}
```


```{r decaimentos_ilustrativos_sup_3D_b, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:1b.1}Exemplos de superfícies do decaimento de $\\overline{G}$ em relação a $\\omega$ e $\\gamma$ para diferentes valores de $\\gamma$ da rede ", net_name, ". (a) Superfície de $\\overline{G}$ da especie com maior valor de $G_{norm}$ da rede. (b) Segundo maior valor de $G_{norm}$. (c) Valor de $G_{norm}$ mais proximo da média geral da rede. (d) Superfície de $\\overline{G}$ referente a uma espécie com valor de $G_{norm}$ abaixo da média da rede."), fig.subcap=c(paste(names(selection[1]),". $G_{norm} =$", format(round(selection[1], 3), nsmall = 3)), paste(names(selection[2]),". $G_{norm} =$", format(round(selection[2], 3), nsmall = 3)), paste(names(selection[3]),". $G_{norm} =$", format(round(selection[3], 3), nsmall = 3)), paste(names(selection[4]),". $G_{norm} =$", format(round(selection[4], 3), nsmall = 3))), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.nrow = 2}

for (i in 1:length(selection)) {
  chosen_node = names(selection[i])
  Plot_G_gamma_omega_suf_3D(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
```


```{r decaimentos_ilustrativos_heatmap_b, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:1b.2}Exemplos de mapas de calor do decaimento de $\\overline{G}$ em relação a $\\omega$ e $\\gamma$ para diferentes valores de $\\gamma$ da rede ", net_name, ". (a) Mapa de calor de $\\overline{G}$ da especie com maior valor de $G_{norm}$ da rede. (b) Segundo maior valor de $G_{norm}$. (c) Valor de $G_{norm}$ mais proximo da média geral da rede. (d) Mapa de calor de $\\overline{G}$ referente a uma espécie com valor de $G_{norm}$ abaixo da média da rede."), fig.subcap=c(paste(names(selection[1]),". $G_{norm} =$", format(round(selection[1], 3), nsmall = 3)), paste(names(selection[2]),". $G_{norm} =$", format(round(selection[2], 3), nsmall = 3)), paste(names(selection[3]),". $G_{norm} =$", format(round(selection[3], 3), nsmall = 3)), paste(names(selection[4]),". $G_{norm} =$", format(round(selection[4], 3), nsmall = 3))), out.width='.49\\linewidth', fig.asp=1, fig.ncol = 2, fig.nrow = 2}

for (i in 1:length(selection)) {
  chosen_node = names(selection[i])
  Plot_G_gamma_omega_heat_3D(seq_Gnorm_gamma_mean, chosen_node, vec_W, gammas)
}
```

## Seleção das espécies com maior $\mathbf{G_{norm}}$.

```{r define_Gnorm_treshold_b}
G_threshold = 1.21
size1 = 3 #tamanho dos nos abixo do G_threshold
size2 = 4*size1 #tamanho dos valores acima de G_threshold

```


A figura \ref{fig:2b} e a tabela \ref{tab:3a} mostram as espécies com valor de $G_{norm}$ acima de `r G_threshold`, ou seja, aquelas com decaimento de $G$ mais lento da rede `r net_name`.

```{r define_aspecto_b}
if (lnum < 4) {
  asp = 0.6
}else{
  asp = 1
}
```


```{r fig-sub2_b, echo = FALSE, fig.cap=paste(fig.cap="\\label{fig:2b}Espécies com G$_{norm}$ maiores que ", G_threshold, "em destaque de tamanho e cor."), fig.asp=asp, nrow = 1, ncol = 3}

Custom_plot2D_destaque_palette(G_norm_mean, links, nodes, layout, size1, size2)

```


```{r, tabela_decimento_lento_b}
selected_nodes = sort(G_norm_mean[which(G_norm_mean > G_threshold)], decreasing = TRUE)
selected_nodes_df = data.frame(names(selected_nodes), format(round(selected_nodes, 3), nsmall = 3))
names(selected_nodes_df) = c("Espécie", "$G_{norm}$")
rownames(selected_nodes_df) = NULL

kable(selected_nodes_df, "latex", booktabs = T, caption = paste("\\label{tab:3a}Espécies com valores de $G_{norm}$ maiores que", G_threshold), escape = FALSE) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

# O que foi visto até o momento

Nas duas redes estudadas, a distribuição dos valores de G$_{norm}$ estão distribuídos como esperado, poucas espécies acima da média da rede e muitas espécies próximas da média ou abaixo dela.

A variação de resolução $\gamma$ não parece influenciar G de forma tão intensa quanto a variação no acoplamento $\omega$, mas ela existe e com certeza é mais robusto selecionar nós com alto G$_{norm}$ como candidatos a centrais considerando a variação em $\gamma$ também, pois assim minizamos a probabilidade de estarmos observando uma exceção dentro de um grande universo de parâmetros de resolução.

Devido a essa variação de G$_{norm}$ em relação a $\gamma$, podemos tentar identificar espécies que sejam boas conectoras entre camadas dentro de módulos menores (submódulos?) que fazem parte de módulos maiores, sendo importantes para a manutenção deste módulo maior de que fazem parte.

As espécies com maior G$_{norm}$ selecionadas possuem boa intersecção com as espécies centrais descritas em @Mello2019 e @Costa2016. Isto é interessante, já que o ranqueamento das espécies foi feito levando em conta a resistência de cada espécie ao parâmetro de acoplamento entre camadas $\omega$. No entanto, ainda preciso comparar numericamente valores de centralidade usando a rede agregada binária e com peso de aresta igual a quantidade de interações em cada camada.

\pagebreak

# Próximas etapas

## Outubro
\begin{itemize}
	\item Compreender melhor o parâmetro de acoplamento $\gamma$ com visualização.
	\item Buscar uma boa forma de visualizar os módulos para rastrear a situação de um nó. Acredito que assim será possível entender melhor como estão posicionados os nós de maior G$_{norm}$ em relação aos módulos ao variarmos $\omega$ e $\gamma$. Acredito que isso ajuadará no insight do que significa na prática essa variável G$_{norm}$ alta que apenas alguns nós possuem.
\end{itemize}

## Novembro
\begin{itemize}
	\item Validar ou desvalidar G$_{norm}$ como forma de localizar espécies que são boas conectoras entre camadas ou centrais de uma forma geral usando diversas redes sintéticas (usar simulação do Rafael Pinheiro) para verificar se o comportamento de G$_{norm}$ é consistente, e compará-lo como outras métricas.
	\item Começar a escrita oficial do TCC.
\end{itemize}


\clearpage

# Referências

<div id="refs"></div>